# ğŸš€ Flow Manager Microservice

This repository contains the design and implementation of a generic **Flow Manager** system, developed as a Python microservice using **FastAPI**.

The Flow Manager executes a sequence of tasks defined in a JSON configuration, using **conditions** to determine the next step based on the outcome (success or failure) of the preceding task. This architecture is ideal for managing critical, multi-step workflows like client onboarding or data processing.

---

## ğŸ’» Technical Stack

- **Framework:** FastAPI (Python 3.14)
- **Dependencies:** `uvicorn`, `pydantic`, `httpx`
- **Design Pattern:** Registry pattern for Task management
- **Testing:** pytest with httpx for async endpoint testing
- **Deployment:** Docker & Docker Compose, AWS EC2 with GitHub Actions CI/CD

---

## ğŸ’¡ Design Explanation

The system is designed to be **generic** and decoupled, separating the task logic from the routing logic.

### Task Dependencies and Execution Flow

The flow does not have hardcoded dependencies. Dependencies are defined **dynamically** within the `conditions` section of the input JSON.

1. The `FlowEngine` reads the `start_task` from the flow configuration.
2. It executes the task using a lookup against the `TASK_REGISTRY` in [tasks.py](file:///Users/andriipopesku/projects/coding-tasks/flow-manager/app/tasks.py).
3. The task execution returns a `TaskResult` object with a `status` field (`"success"` or `"failure"`) and optional `data`.
4. The Engine then searches the `conditions` list for a rule where the `source_task` matches the task just completed.
5. Based on the result status, the Engine selects the next step by choosing either the `target_task_success` or `target_task_failure`.

### Success/Failure Evaluation

A task's success or failure is determined by the `status` field in the `TaskResult` object returned by its corresponding Python function in [tasks.py](file:///Users/andriipopesku/projects/coding-tasks/flow-manager/app/tasks.py). In a real-world scenario, this return value would likely be based on:

- Checking the HTTP status code of an external API call (e.g., `200` for success).
- A database transaction status.
- The absence of exceptions during execution.

### Handling Task Outcomes

The flow is designed for **sequential execution with immediate termination on failure**.

- **On Success:** The flow proceeds to the task specified by `target_task_success` (e.g., `task2` after `task1` succeeds).
- **On Failure:** The flow immediately terminates by setting the next target to `"end"`.

### Architecture Components

```
flow-manager/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ engine.py          # FlowEngine - Core execution logic
â”‚   â”œâ”€â”€ main.py            # FastAPI application entry point
â”‚   â”œâ”€â”€ routes.py          # API route definitions
â”‚   â”œâ”€â”€ schemas.py         # Pydantic models for validation
â”‚   â”œâ”€â”€ tasks.py           # Task registry and implementations
â”‚   â”œâ”€â”€ logging_config.py  # Logging configuration
â”‚   â””â”€â”€ sample_flow.json   # Example flow configuration
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_api.py        # API endpoint tests
â”‚   â””â”€â”€ test_core.py       # Core engine tests
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â””â”€â”€ deploy_beta.yml # CI/CD pipeline for AWS EC2
â”œâ”€â”€ Dockerfile             # Container image definition
â”œâ”€â”€ docker-compose.yml     # Local development setup
â””â”€â”€ pyproject.toml         # Project metadata and dependencies
```

---

## ğŸ› ï¸ Setup and Execution

### Prerequisites

You need **Python 3.10+** installed.

### Installation

#### Using uv (Recommended)

[uv](https://github.com/astral-sh/uv) is a fast Python package installer and virtual environment manager.

```bash
# Install uv (macOS/Linux)
curl -LsSf https://astral.sh/uv/install.sh | sh

# Or with Homebrew
brew install uv

# Clone the repository
git clone https://github.com/AndrewPopesku/flow-manager.git
cd flow-manager

# Set up the project (creates venv and installs dependencies)
uv sync
```

#### Using traditional pip

```bash
# Clone the repository
git clone https://github.com/AndrewPopesku/flow-manager.git
cd flow-manager

# Create a virtual environment
python -m venv .venv

# Activate the virtual environment
source .venv/bin/activate  # On macOS/Linux
# .venv\Scripts\activate   # On Windows

# Install dependencies
pip install .
```

### Running the Microservice

#### Development Server

```bash
# With uv
uv run uvicorn app.main:app --reload

# Or with traditional approach
uvicorn app.main:app --reload
```

The microservice will be available at `http://127.0.0.1:8000`.

#### Using Docker

```bash
# Build the image
docker build -t flow-manager .

# Run the container
docker run -p 8000:8000 flow-manager
```

### API Documentation

The clear API requirement is met via **Swagger UI** (OpenAPI documentation), automatically generated by FastAPI:

- **Swagger UI:** `http://127.0.0.1:8000/docs`
- **ReDoc:** `http://127.0.0.1:8000/redoc`

---

## ğŸ”Œ API Usage

### Execute Flow Endpoint

**Endpoint:** `POST /flow/execute`

**Request Body:**

```json
{
  "flow": {
    "name": "Data processing flow",
    "start_task": "task1",
    "tasks": [
      { "name": "task1", "description": "Fetch data" },
      { "name": "task2", "description": "Process data" },
      { "name": "task3", "description": "Store data" }
    ],
    "conditions": [
      {
        "name": "condition_task1_result",
        "description": "Evaluate task1. If success -> task2, else -> end",
        "source_task": "task1",
        "outcome": "success",
        "target_task_success": "task2",
        "target_task_failure": "end"
      },
      {
        "name": "condition_task2_result",
        "description": "Evaluate task2. If success -> task3, else -> end",
        "source_task": "task2",
        "outcome": "success",
        "target_task_success": "task3",
        "target_task_failure": "end"
      }
    ]
  }
}
```

**Response:**

```json
{
  "message": "Flow executed successfully",
  "flow_id": "550e8400-e29b-41d4-a716-446655440000",
  "execution_history": {
    "task1": {
      "status": "success",
      "data": { "raw_data": "data" }
    },
    "task2": {
      "status": "success",
      "data": { "processed_data": "data" }
    },
    "task3": {
      "status": "success",
      "data": { "storage_id": "12345" }
    }
  }
}
```

### Example API Call

Using `curl`:

```bash
curl -X POST "http://127.0.0.1:8000/flow/execute" \
  -H "Content-Type: application/json" \
  -d @app/sample_flow.json
```

Using the Swagger UI:
1. Navigate to `http://127.0.0.1:8000/docs`
2. Click on the `POST /flow/execute` endpoint
3. Click "Try it out"
4. Use the sample payload or modify as needed
5. Click "Execute"

---

## ğŸ§ª Running Tests

```bash
# With uv
uv run pytest

# Or traditional approach
pytest

# With coverage
uv run pytest --cov=app --cov-report=html
```

---

## ğŸš¢ Deployment

### AWS EC2 Deployment

The project includes a GitHub Actions CI/CD pipeline that automatically deploys to AWS EC2 on push to the `main` branch.

**Workflow:** [.github/workflows/deploy_beta.yml](file:///Users/andriipopesku/projects/coding-tasks/flow-manager/.github/workflows/deploy_beta.yml)

**Required GitHub Secrets:**
- `EC2_HOST` - EC2 instance public IP or hostname
- `EC2_USER` - SSH username (e.g., `ubuntu`)
- `EC2_SSH_KEY` - Private SSH key for EC2 access

The deployment process:
1. Runs tests to ensure code quality
2. Connects to EC2 via SSH
3. Pulls latest code from GitHub
4. Builds and deploys using Docker Compose

---

## ğŸ“ Adding New Tasks

To add a new task to the system:

1. Open [app/tasks.py](file:///Users/andriipopesku/projects/coding-tasks/flow-manager/app/tasks.py)
2. Define your task function using the `@register_task` decorator:

```python
@register_task("my_new_task")
def my_new_task() -> TaskResult:
    """
    Description of what this task does.
    """
    logger.info("Executing my_new_task...")
    # Your task logic here
    return TaskResult(status="success", data={"result": "value"})
```

3. Update your flow JSON to include the new task in the `tasks` array and add appropriate conditions.

---

## ğŸ—ï¸ Design Patterns

### Registry Pattern

The system uses the **Registry Pattern** for task management:

- Tasks are registered using the `@register_task` decorator
- The `TASK_REGISTRY` dictionary maps task names to their implementations
- This allows for dynamic task lookup and execution without hardcoded dependencies

### Separation of Concerns

- **Schemas** ([schemas.py](file:///Users/andriipopesku/projects/coding-tasks/flow-manager/app/schemas.py)): Data validation and models
- **Tasks** ([tasks.py](file:///Users/andriipopesku/projects/coding-tasks/flow-manager/app/tasks.py)): Business logic implementations
- **Engine** ([engine.py](file:///Users/andriipopesku/projects/coding-tasks/flow-manager/app/engine.py)): Flow execution and control logic
- **Routes** ([routes.py](file:///Users/andriipopesku/projects/coding-tasks/flow-manager/app/routes.py)): API endpoint definitions

---

## ğŸ” Key Features

- âœ… **Generic Flow Definition**: Define any number of tasks and conditions via JSON
- âœ… **Dynamic Execution**: Tasks are executed based on runtime conditions
- âœ… **Error Handling**: Graceful failure handling with detailed execution history
- âœ… **Type Safety**: Full Pydantic validation for all inputs and outputs
- âœ… **Auto-generated Documentation**: OpenAPI/Swagger UI for easy API exploration
- âœ… **Containerized**: Docker support for consistent deployment
- âœ… **CI/CD Ready**: GitHub Actions workflow for automated testing and deployment
- âœ… **Extensible**: Easy to add new tasks via the registry pattern

---

## ğŸ“„ License

This project is developed as a technical assignment demonstrating microservice architecture and workflow management capabilities.

---

## ğŸ‘¨â€ğŸ’» Author

**Andrii Popesku**

GitHub: [@AndrewPopesku](https://github.com/AndrewPopesku)